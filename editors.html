<!doctype html>
<html>
      <!--
      TODO:

      Language:
        - Work on handling parse errors
        - SyntaxError expression
        - Tabular data
        - Metadata

      Evaluator:
        - Yes

      Editor:
        - Tree Motions (In, Out, Next, Prev)
        - Tabular data
        - Restricted tabular data for let bindings?
        - Mode line for help
        - Replace content-edit with textarea for code?
        - Take an external editor?

      -->
  <head>
    <title>Playing with Editors</title>
    <style type="text/css">
     .block { margin-top: 10px; margin-bottom: 10px; position: relative; border: 1px solid transparent; }
     .label { display: inline-block; vertical-align: top; width: 180px; padding-right: 20px; text-align: right; font-style: italic; }
     .code { display: inline-block; vertical-align: top; width: 500px; white-space: pre; font-family: Consolas; }
     .text { display: inline-block; vertical-align: top; width: 500px; }
     .result { display: inline-block; vertical-align: top; font-style: italic; }

     .code div { display: inline-block; vertical-align: top; position: relative; }

     .code div .bindings { display: block; margin-left: 20px; }
     .code div .binding  { display: block; }

     .identifierExpression { margin-left: 3px; color: green; }
     .keyword { margin-left: 3px; color: blue; }
     .operator { margin-left: 3px; }
     .decl { margin-left: 3px; }

     .applyExpression .arg { margin-left: 5px; }

     .selected { border: 1px solid blue; }
    </style>
  </head>
  <body>
    <div id="root">
    </div>
    <script type="text/javascript" src="lex.js"></script>
    <script type="text/javascript" src="parse.js"></script>
    <script type="text/javascript" src="render.js"></script>
    <script type="text/javascript">
      // Block metadata
      //
      var blockTypes = {
        'textBlock': {
          contentClassName: 'text',
          setContent: function setTextContent(block, text) {
            block.content = text;
          },
          getContentElement: function getTextContent(block) {
            // TODO: Creole conversion to HTML, once the parser is working.
            var e = document.createElement('div');
            e.className = 'text';
            if (block.content) {
              e.innerText = block.content;
            }
            return e;
          },
          getContentText: function getTextContentText(block) {
            return block.content;
          }
        },
        'codeBlock': {
          contentClassName: 'code',
          setContent: function setCodeContent(block, text) {
            var toks = lex(text);
            var tree = parse(toks);
            block.code = { text: text, tokens: toks, tree: tree };
          },
          getContentElement: function getCodeContent(block) {
            return renderNode("code", block.code.tree);
          },
          getContentText: function getTextContentText(block) {
            return block.code.text;
          }
        }
      };

      // Rendering and DOM structure
      //
      function renderBlock(block) {
        var labelElement = document.createElement('div');
        labelElement.className = 'label';
        if (block.label) {
          labelElement.innerText = block.label;
        }

        var codeElement = blockTypes[block.kind].getContentElement(block);

        var resultElement = document.createElement('div');
        resultElement.className = 'result';
        if (block.result) {
          resultElement.innerText = block.result;
        }

        var elem = document.createElement('div');
        elem.className = 'block';
        elem.appendChild(labelElement);
        elem.appendChild(codeElement);
        elem.appendChild(resultElement);
        elem.attachedBlock = block;

        return elem;
      }

      function renderNotebook(notebook) {
        var root = document.getElementById('root');
        notebook.blocks.forEach(function eachBlock(block) {
          root.appendChild(renderBlock(block));
        });
      }

      function getPart(element, part) {
        return element.getElementsByClassName(part)[0];
      }

      // Selection management.
      //
      var selectedElement;

      function attachedBlock(element) {
        var elem = element;
        while(elem) {
          if (elem.attachedBlock) { return elem.attachedBlock; }
          elem = elem.parentElement;
        }
        return null;
      }

      function selectedBlock() {
        return attachedBlock(selectedElement);
      }

      function blockElement(block) {
        var blockElements = document.getElementById('root').children;
        for(var i = 0; i < blockElements.length; i++) {
          var elem = blockElements[i];
          if (attachedBlock(elem) === block) {
            return elem;
          }
        }
        return null;
      }


      function selectedBlockElement() {
        return blockElement(selectedBlock());
      }

      function selectElement(elem) {
        if (selectedElement) {
          selectedElement.contentEditable = false;
          selectedElement.classList.remove('selected');
        }
        selectedElement = elem;
        if (selectedElement) {
          selectedElement.classList.add('selected');
          selectedElement.focus();
        }
      }

      function selectBlock(block) {
        selectElement(blockElement(block));
      }

      function nextBlock(notebook, block) {
        if (notebook.blocks.length === 0) { return null; }

        var index = (notebook.blocks.indexOf(block) + 1) % notebook.blocks.length;
        return notebook.blocks[index];
      }

      function previousBlock(notebook, block) {
        if (notebook.blocks.length === 0) { return null; }

        var index = notebook.blocks.indexOf(block);
        if (index <= 0) {
          return notebook.blocks[notebook.blocks.length - 1];
        } else {
          return notebook.blocks[index - 1];
        }
      }

      function insertBlockAfter(notebook, block, pred) {
        var index = notebook.blocks.indexOf(pred) + 1;
        notebook.blocks.splice(index, 0, block);
      }


      // Merge block
      // Move block up
      // Move block down
      // Split block
      // Edit content
      // Edit label

      // Editor Commands
      function editElement(element, modeName) {
        selectElement(element);
        element.contentEditable = true;
        element.focus();
        mode = modes[modeName];
      }

      function insertBlock(block) {
        var elem = selectedBlockElement();

        insertBlockAfter(notebook, block, attachedBlock(elem));

        var newElem = renderBlock(block);
        elem.parentElement.insertBefore(newElem, elem.nextSibling);

        return newElem;
      }

      function replaceBlockContent(block) {
        var element = blockElement(block);
        var type = blockTypes[block.kind];
        var newElement = type.getContentElement(block);
        var oldElement = getPart(element, type.contentClassName);

        oldElement.parentNode.replaceChild(newElement, oldElement);
      }

      var commands = {
        selectPrevious: function selectPrevious() { selectBlock(previousBlock(notebook, selectedBlock())); },
        selectNext:     function selectNext() { selectBlock(nextBlock(notebook, selectedBlock())); },
        selectNone:     function selectNone() { selectBlock(null); },

        editLabel:      function editLabel() {
          if (selectedElement === null) { return; }
          editElement(getPart(selectedBlockElement(), 'label'), 'editLabel');
        },

        editContent:   function editContent() {
          if (selectedElement === null) { return; }

          var block = selectedBlock();
          var className = blockTypes[block.kind].contentClassName;

          var element = getPart(blockElement(block), className);
          element.innerText = blockTypes[block.kind].getContentText(block);

          editElement(element, 'editContent');
        },

        insertCodeBlock: function insertCodeBlock() {
          selectElement(insertBlock({'kind': 'codeBlock', 'code': '...'}));
        },

        insertTextBlock: function insertTextBlock() {
          selectElement(insertBlock({'kind': 'textBlock', 'content': '...'}));
        },
      };

      var modes = {
        'select': {
          'Up':             commands.selectPrevious,
          'Down':           commands.selectNext,
          'U+001B': /*ESC*/ commands.selectNone,
          'F2':             commands.editLabel,
          'U+004C': /* l */ commands.editLabel,
          'U+0043': /* c */ commands.editContent,
          'Enter':          commands.editContent,
          'U+004F': /* o */ commands.insertCodeBlock,
          'U+0049': /* i */ commands.insertTextBlock
        },

        'editContent': {
          'U+001B': /*ESC*/ function() { // ESC
            var block = attachedBlock(selectedElement);

            var type = blockTypes[block.kind];
            type.setContent(block, selectedElement.innerText);
            var newContent = type.getContentElement(block);

            selectBlock(block);
            replaceBlockContent(block);

            mode = modes['select'];
          },
        },

        'editLabel': {
          'U+001B': function() { // ESC
            var label = selectedElement.innerText.trim();
            selectedElement.innerText = label;

            var block = attachedBlock(selectedElement);
            block.label = label;
            selectBlock(block);

            mode = modes['select'];
          },
          'Enter': 'U+001B'
        }
      }

      var mode = modes['select'];

      document.body.onkeyup = function editorKeyUp(evt) {
        evt = evt || window.event;
        kid = evt.key || evt.keyIdentifier;
        handler = mode[kid];
        if (handler) {
          while (typeof(handler) === 'string') {
            handler = mode[handler];
          }
          handler(evt);
        } else {
          console.log(kid);
        }
      };
    </script>
    <script type="text/javascript">
     // The document
     var text_one = 'let x = fn a b c d => a + b + c + d;\n    y = x 1 2;\n    in y 5';
     var toks = lex(text_one);
     var tree = parse(toks);

     var notebook = {
       blocks: [
         {
           kind: 'textBlock',
           content: '= This little notebook is a program.\n\nA notebook has text, like this, interspersed with code.\n\nHere\'s some code:'
         },
         {
           // This is wrong because you really want to store the tree, of course.
           kind: 'codeBlock',
           label: 'Function One',
           code: {
             text: text_one,
             tokens: toks,
             tree: tree
           },
           result: 'fn x : int -> int'
         },
         {
           kind: 'textBlock',
           content: 'As you can see, that was a function that returned a function.'
         }
       ]
     };

     renderNotebook(notebook);
    </script>
  </body>
</html>
