<!doctype html>
<html>
  <head>
    <title>Playing with Editors</title>
    <style type="text/css">
     .block { margin-top: 10px; margin-bottom: 10px; position: relative; border: 1px solid transparent; }
     .label { display: inline-block; vertical-align: top; width: 180px; padding-right: 20px; text-align: right; font-style: italic; }
     .code { display: inline-block; vertical-align: top; width: 500px; white-space: pre; font-family: Consolas; }
     .text { display: inline-block; vertical-align: top; width: 500px; }
     .result { display: inline-block; vertical-align: top; font-style: italic; }

     .identifier { color: green; }
     .keyword { color: blue; }

     .selected { border: 1px solid blue; }
    </style>
  </head>
  <body>
    <div id="root">
    </div>
    <script type="text/javascript">
     // Lexer
     var tokenType = {
       identifier: 1, numberLiteral: 2,
       equals: 100, arrow: 101, plus: 102, minus: 103, multiply: 104, divide: 105,
       letKeyword: 200, fnKeyword: 201, inKeyword: 202, semicolon: 203,
       eof: 900, whitespace: 901, error: 999,
     };
     function tokenTypeName(type) {
       var keys = Object.keys(tokenType);
       for (var i = 0, len = keys.length; i < len; i++) {
         if (type === tokenType[keys[i]]) {
           return keys[i];
         }
       }
       return "<unknown>";
     }
     var lex = (function() {
       var tokens = {
         equals:     { type: tokenType.equals,     value: "=",   length: 1 },
         arrow:      { type: tokenType.arrow,      value: "=>",  length: 2 },
         plus:       { type: tokenType.plus,       value: "+",   length: 1 },
         minus:      { type: tokenType.minus,      value: "-",   length: 1 },
         multiply:   { type: tokenType.multiply,   value: "*",   length: 1 },
         divide:     { type: tokenType.divide,     value: "/",   length: 1 },
         letKeyword: { type: tokenType.letKeyword, value: "let", length: 3, keyword: true },
         fnKeyword:  { type: tokenType.fnKeyword,  value: "fn",  length: 2, keyword: true },
         inKeyword:  { type: tokenType.inKeyword,  value: "in",  length: 2, keyword: true },
         semicolon:  { type: tokenType.semicolon,  value: ";",   length: 1 },
         eof:        { type: tokenType.eof,                      length: 0 }
       };
       function reservedWordLookup(identifier) {
         switch (identifier.charCodeAt(0)) {
           case /*f*/102:
             switch (identifier) {
               case 'fn': return tokens.fnKeyword;
             }
             break;

           case /*i*/105:
             switch (identifier) {
               case 'in': return tokens.inKeyword;
             }
             break;

           case /*l*/108:
             switch (identifier) {
               case 'let': return tokens.letKeyword;
             }
             break;
         }
         return;
       }
       function isIdentifierStartCharacter(code) {
         switch (code) {
           case (code >= /*a*/97 && code <= /*z*/122) && code:
           case (code >= /*A*/65 && code <= /*Z*/90) && code:
           case /*$*/36:
           case /*_*/95:
             return true;
           default:
             return false;
         }
       }
       function readIdentifierPart(text, offset, limit) {
         while (offset < limit) {
           var code = text.charCodeAt(offset);
           switch (code) {
             case (code >= /*a*/97 && code <= /*z*/122) && code: // (Inlined isIdentifierStartCharacter)
             case (code >= /*A*/65 && code <= /*Z*/90) && code:
             case /*$*/36:
             case /*_*/95:
               break;
             case (code >= /*0*/48 && code <= /*9*/57) && code: // (Inlined isDecimalDigit)
               break;
             default:
               return offset;
           }
           offset++;
         }
         return offset;
       }
       function readIdentifierToken(text, start, offset, limit) {
         offset = readIdentifierPart(text, offset, limit);
         var length = offset - start;

         var value = text.substr(start, length);
         return reservedWordLookup(value) || { type: tokenType.identifier, length: length, value: value };
       }
       function isDecimalDigit(code) {
         return (code >= /*0*/48 && code <= /*9*/57) && code;
       }
       function readDecimalDigits(text, offset, limit) {
         while (offset < limit && isDecimalDigit(text.charCodeAt(offset))) {
           offset++;
         }
         return offset;
       }
       function readDecimalLiteral(text, offset, limit) {
         offset = readDecimalDigits(text, offset, limit);
         if (offset < limit && text.charCodeAt(offset) === /*.*/46 && offset + 1 < limit && isDecimalDigit(text.charCodeAt(offset + 1))) {
           offset = readDecimalDigits(text, offset + 2, limit);
         }
         if (offset < limit) {
           var code = text.charCodeAt(offset);
           if (code === /*e*/101 || code === /*E*/69) {
             var tempOffset = offset + 1;
             if (tempOffset < limit) {
               code = text.charCodeAt(tempOffset);
               if (code === /*+*/43 || code === /*-*/45) {
                 tempOffset++;
               }
               offset = readDecimalDigits(text, tempOffset, limit);
             }
           }
         }
         return offset;
       }
       function readDecimalLiteralToken(text, start, offset, limit) {
         offset = readDecimalLiteral(text, offset, limit);
         var length = offset - start;

         return { type: tokenType.numberLiteral, length: length, value: text.substr(start, length) };
       }
       function isWhitespace(code) {
         switch (code) {
           case 0x0009:    // tab
           case 0x000A:    // line feed
           case 0x000B:    // vertical tab
           case 0x000C:    // form feed
           case 0x000D:    // carriage return
           case 0x0020:    // space
           case 0x00A0:    // no-breaking space
           case 0x1680:    // Unicode category Zs follow:
           case 0x180e:
           case (code >= 0x2000 && code <= 0x200a) && code:
           case 0x2028:    // line separator
           case 0x2029:    // paragraph separator
           case 0x202f:
           case 0x205f:
           case 0x3000:
           case 0xFEFF:    // BOM
             return true;

           default:
             return false;
         }
       }
       function readWhitespace(text, offset, limit) {
         while (offset < limit) {
           var code = text.charCodeAt(offset);
           if (!isWhitespace(code)) { return offset; }
           offset++;
         }
         return offset;
       }
       function readWhitespaceToken(text, start, offset, limit) {
         offset = readWhitespace(text, offset);
         var length = offset - start;

         return { type: tokenType.whitespace, length: length, value: text.substr(start, length) };
       }
       return function lex(text, offset, limit) {
         offset = offset || 0;
         limit = limit || text.length;

         var result = [];
         while (offset < limit) {
           var startOffset = offset;
           var code = text.charCodeAt(offset++);
           var type;
           var token;

           switch (code) {
             case isWhitespace(code) && code:
               token = readWhitespaceToken(text, startOffset, offset, limit);
               break;

             case /* * */42: token = tokens.multiply; break;
             case /* / */47: token = tokens.divide; break;

             case /*+*/43:
             case /*-*/45:
               if (offset < limit) {
                 var afterSign = text.charCodeAt(offset);
                 if (afterSign === /*.*/46) {
                   var signOffset = offset + 1;
                   if (signOffset < limit && isDecimalDigit(text.charCodeAt(signOffset))) {
                     token = readDecimalLiteralToken(text, startOffset, signOffset, limit);
                     break;
                   }
                 } else if (isDecimalDigit(afterSign)) {
                   token = readDecimalLiteralToken(text, startOffset, offset, limit);
                   break;
                 }
               }
               if (code === /*+*/43) {
                 token = tokens.plus;
               } else {
                 token = tokens.minus;
               }
               break;

             case (code >= /*0*/48 && code <= /*9*/57) && code:
               token = readDecimalLiteralToken(text, startOffset, offset, limit);
               break;

             case /*;*/59:
               token = tokens.semicolon;
               break;

             case /*=*/61:
               if (offset < limit && text.charCodeAt(offset) === /*>*/62) {
                 token = tokens.arrow;
               } else {
                 token = tokens.equals;
               }
               break;

             case isIdentifierStartCharacter(code) && code:
               token = readIdentifierToken(text, startOffset, offset, limit);
               break;

             default:
               // TODO: Suppress duplicate error tokens; merge them together. Or resync on whitespace?
               token = { type: tokenType.error, length: offset - startOffset, value: text.substring(startOffset, offset) };
               break;
           }

           offset += (token.length - 1);
           result.push(token);
         }
         result.push(tokens.eof);
         return result;
       }
     })();
    </script>
    <script type="text/javascript">
     // Parser.
     var nodeType = {
       apply: 1,identifier: 2,literal: 3,
       let: 100, fn: 101, binding: 102,
       binaryOperator: 1000,
       syntaxError: 9000
     };
     function nodeTypeName(type) {
       var keys = Object.keys(nodeType);
       for (var i = 0, len = keys.length; i < len; i++) {
         if (type === nodeType[keys[i]]) {
           return keys[i];
         }
       }
       return "<unknown>";
     }
     var parse = function() {
       // Prefix expressions
       function parseIdentifier(token_stream, token) {
         return { type: nodeType.identifier, value: token };
       }

       function parseLiteral(token_stream, token) {
         return { type: nodeType.literal, value: token };
       }

       function parseFn(token_stream, token) {
         var params = [];
         while (token_stream.peek().type === tokenType.identifier) {
           params.push(token_stream.read());
         }
         var arrow = token_stream.read(tokenType.arrow);
         var expr = parseExpression(token_stream, precedence.fn);
         return { type: nodeType.fn, params: params, arrow: arrow, expr: expr, children: [expr] };
       }

       function parseBindings(token_stream) {
         var bindings = []
         do {
           if (token_stream.peek().type === tokenType.semicolon) { token_stream.read(); }
           if (token_stream.peek().type === tokenType.inKeyword) { break; }

           var id = token_stream.read(tokenType.identifier);
           var equals = token_stream.read(tokenType.equals);
           var val = parseExpression(token_stream, precedence.let);

           bindings.push({ type: nodeType.binding, decl: id, expr: val, equals: equals, children: [ val ] });
         } while(token_stream.peek().type === tokenType.semicolon);

         return bindings;
       }

       function parseLet(token_stream, token) {
         // Token is already let.
         var bindings = parseBindings(token_stream);
         var in_ = token_stream.read(tokenType.inKeyword);
         var expr = parseExpression(token_stream, precedence.let);

         var children = bindings.concat(expr);
         return { type: nodeType.let, let: token, bindings: bindings, in_: in_, expr: expr, children: children };
       }

       // Infix expressions
       function parseBinaryOperator(precedence) {
         return {
           precedence: precedence,
           parse: function(token_stream, left, token) {
             var right = parseExpression(token_stream, precedence);
             return { type: nodeType.binaryOperator, children: [ left, right ], op: token };
           }
         };
       }

       function parseApply(token_stream, left, token) {
         // This is kinda like parseExpression, 'cept the token has already
         // been read for us and we know it's a prefix of something. 'left',
         // as provided by the caller, is the expression that resolves to the
         // function.
         //
         var rest = prefix_table[token.type](token_stream, token);
         rest = parseInfix(token_stream, precedence.apply, rest);

         return { type : nodeType.apply, fn: left, arg: rest, children: [left, rest] };
       }

       // Parser tables.
       function parser_table(table) {
         return table.reduce(function (p, c) { p[c.token] = c.parser; }, {});
       }

       var prefix_tokens = [
         { token: tokenType.identifier,    parser: parseIdentifier },
         { token: tokenType.numberLiteral, parser: parseLiteral },
         { token: tokenType.fnKeyword,     parser: parseFn },
         { token: tokenType.letKeyword,    parser: parseLet },
       ];

       var precedence = {
         let:      2,
         fn:       3,
         add:      4,
         multiply: 5,
         apply:    6
       };

       var infix_tokens = [
         { token: tokenType.plus,     parser: parseBinaryOperator(precedence.add) },
         { token: tokenType.minus,    parser: parseBinaryOperator(precedence.add) },
         { token: tokenType.multiply, parser: parseBinaryOperator(precedence.multiply) },
         { token: tokenType.divide,   parser: parseBinaryOperator(precedence.multiply) }
       ];

       // The prefix table is generated by creating a map from the token field to the parser field.
       //
       var prefix_table = prefix_tokens.reduce(function (p,c) { p[c.token] = c.parser; return p; }, {});

       // The infix table is a map of the infix_tokens table, from the token
       // field to the parser field. In addition, for every token in the
       // prefix_tokens table that is not also in the infix_tokens table, a
       // row is added that recognizes the token as infix application.
       //
       var infix_table = (function() {
         var apply_tokens = prefix_tokens.reduce(function (p,c) {
           p[c.token] = { precedence: precedence.apply, parse: parseApply };
           return p;
         }, {});

         return infix_tokens.reduce(
           function (p,c) { p[c.token] = c.parser; return p; },
           Object.create(apply_tokens));
       })();

       function nextPrecedence(token_stream) {
         var infix = infix_table[token_stream.peek().type];
         if (infix) { return infix.precedence; }
         return 0;
       }

       function parseInfix(token_stream, precedence, left) {
         while (precedence < nextPrecedence(token_stream)) {
           token = token_stream.read();
           left = infix_table[token.type].parse(token_stream, left, token);
         }

         return left;
       }

       function parseExpression(token_stream, precedence) {
         var token = token_stream.read();
         var left = prefix_table[token.type](token_stream, token);

         return parseInfix(token_stream, precedence, left);
       }

       return function parse(tokens) {
         var index = 0;
         function skipWhitespace() {
           while(tokens[index].type === tokenType.whitespace) {
             index++;
           }
         }
         var token_stream = {
           read: function read(type) {
             skipWhitespace();
             var token = tokens[index++];
             if (type && token.type !== type) {
               // TODO: ERROR in a sane way, though.
               throw new Error("Parse error: expected " + tokenTypeName(type) + " but got " + tokenTypeName(token.type));
             }
             return token;
           },
           peek: function peek() { skipWhitespace(); return tokens[index]; },
         };

         return parseExpression(token_stream, 0);
       }
     }();

     var dumpTree = (function() {
       function nodeName(node) {
         var name = nodeTypeName(node.type);
         if (node.params) {
           name = node.params.reduce(function (p,c) { return p + " " + c.value; }, name);
         }
         if (node.op) { name += " " + node.op.value; }
         if (node.decl) { name += " " + node.decl.value + "="; }
         if (node.value) { name += ' (' + node.value.value + ')'; }
         return name;
       }

       return function dumpTree(t) {
         var name = nodeName(t);
         if (t.children) {
           console.group(name);
           var i = 0;
           for (i = 0; i < t.children.length; i++) {
             dumpTree(t.children[i]);
           }
           console.groupEnd(name);
         } else {
           console.log(name);
         }
       }
     })();
    </script>
    <script type="text/javascript">
      var notebook = {
        blocks: [
          {
            kind: 'textBlock',
            content: '= This little notebook is a program.\n\nA notebook has text, like this, interspersed with code.\n\nHere\'s some code:'
          },
          {
            // This is wrong because you really want to store the tree, of course.
            kind: 'codeBlock',
            label: 'Function One',
            code: 'let x = fn a b c d => a + b + c + d;\n    y = x 1 2;\n    in y 5',
            result: 'fn x : int -> int'
          },
          {
            kind: 'textBlock',
            content: 'As you can see, that was a function that returned a function.'
          }
        ]
      };

      // Block metadata
      //
      var blockTypes = {
        'textBlock': {
          contentClassName: 'text',
          setContent: function setTextContent(block, text) {
            block.content = text;
          },
          getContentElement: function getTextContent(block) {
            // TODO: Creole conversion to HTML, once the parser is working.
            var e = document.createElement('div');
            e.className = 'text';
            if (block.content) {
              e.innerText = block.content;
            }
            return e;
          }
        },
        'codeBlock': {
          contentClassName: 'code',
          setContent: function setCodeContent(block, text) {
            block.code = text;
          },
          getContentElement: function getCodeContent(block) {
            var e = document.createElement('div');
            e.className = 'code';

            lex(block.code).forEach(function handleToken(token) {
              if (token.type === tokenType.eof) { return; }

              var span = document.createElement('span');
              if (token.keyword) {
                span.className = 'keyword';
              } else if (token.type === tokenType.identifier) {
                span.className = 'identifier';
              } else if (token.type === tokenType.error) {
                span.className = 'errorToken';
              }
              span.innerText = token.value;
              e.appendChild(span);
            });

            return e;
          }
        }
      };

      // Rendering and DOM structure
      //
      function renderBlock(block) {
        var labelElement = document.createElement('div');
        labelElement.className = 'label';
        if (block.label) {
          labelElement.innerText = block.label;
        }

        var codeElement = blockTypes[block.kind].getContentElement(block);

        var resultElement = document.createElement('div');
        resultElement.className = 'result';
        if (block.result) {
          resultElement.innerText = block.result;
        }

        var elem = document.createElement('div');
        elem.className = 'block';
        elem.appendChild(labelElement);
        elem.appendChild(codeElement);
        elem.appendChild(resultElement);
        elem.attachedBlock = block;

        return elem;
      }

      function renderNotebook(notebook) {
        var root = document.getElementById('root');
        notebook.blocks.forEach(function eachBlock(block) {
          root.appendChild(renderBlock(block));
        });
      }

      function getPart(element, part) {
        return element.getElementsByClassName(part)[0];
      }

      // Selection management.
      //
      var selectedElement;

      function attachedBlock(element) {
        var elem = element;
        while(elem) {
          if (elem.attachedBlock) { return elem.attachedBlock; }
          elem = elem.parentElement;
        }
        return null;
      }

      function selectedBlock() {
        return attachedBlock(selectedElement);
      }

      function blockElement(block) {
        var blockElements = document.getElementById('root').children;
        for(var i = 0; i < blockElements.length; i++) {
          var elem = blockElements[i];
          if (attachedBlock(elem) === block) {
            return elem;
          }
        }
        return null;
      }


      function selectedBlockElement() {
        return blockElement(selectedBlock());
      }

      function selectElement(elem) {
        if (selectedElement) {
          selectedElement.contentEditable = false;
          selectedElement.classList.remove('selected');
        }
        selectedElement = elem;
        if (selectedElement) {
          selectedElement.classList.add('selected');
          selectedElement.focus();
        }
      }

      function selectBlock(block) {
        selectElement(blockElement(block));
      }

      function nextBlock(notebook, block) {
        if (notebook.blocks.length === 0) { return null; }

        var index = (notebook.blocks.indexOf(block) + 1) % notebook.blocks.length;
        return notebook.blocks[index];
      }

      function previousBlock(notebook, block) {
        if (notebook.blocks.length === 0) { return null; }

        var index = notebook.blocks.indexOf(block);
        if (index <= 0) {
          return notebook.blocks[notebook.blocks.length - 1];
        } else {
          return notebook.blocks[index - 1];
        }
      }

      function insertBlockAfter(notebook, block, pred) {
        var index = notebook.blocks.indexOf(pred) + 1;
        notebook.blocks.splice(index, 0, block);
      }


      // Merge block
      // Move block up
      // Move block down
      // Split block
      // Edit content
      // Edit label

      // Editor Commands
      function editElement(element, modeName) {
        selectElement(element);
        element.contentEditable = true;
        element.focus();
        mode = modes[modeName];
      }

      function insertBlock(block) {
        var elem = selectedBlockElement();

        insertBlockAfter(notebook, block, attachedBlock(elem));

        var newElem = renderBlock(block);
        elem.parentElement.insertBefore(newElem, elem.nextSibling);

        return newElem;
      }

      function replaceBlockContent(block) {
        var element = blockElement(block);
        var type = blockTypes[block.kind];
        var newElement = type.getContentElement(block);
        var oldElement = getPart(element, type.contentClassName);

        oldElement.parentNode.replaceChild(newElement, oldElement);
      }

      var commands = {
        selectPrevious: function selectPrevious() { selectBlock(previousBlock(notebook, selectedBlock())); },
        selectNext:     function selectNext() { selectBlock(nextBlock(notebook, selectedBlock())); },
        selectNone:     function selectNone() { selectBlock(null); },

        editLabel:      function editLabel() {
          if (selectedElement === null) { return; }
          editElement(getPart(selectedBlockElement(), 'label'), 'editLabel');
        },

        editContent:   function editContent() {
          if (selectedElement === null) { return; }

          var block = selectedBlock();
          var className = blockTypes[block.kind].contentClassName;

          editElement(getPart(blockElement(block), className), 'editContent');
        },

        insertCodeBlock: function insertCodeBlock() {
          selectElement(insertBlock({'kind': 'codeBlock', 'code': '...'}));
        },

        insertTextBlock: function insertTextBlock() {
          selectElement(insertBlock({'kind': 'textBlock', 'content': '...'}));
        },
      };

      var modes = {
        'select': {
          'Up':             commands.selectPrevious,
          'Down':           commands.selectNext,
          'U+001B': /*ESC*/ commands.selectNone,
          'F2':             commands.editLabel,
          'U+004C': /* l */ commands.editLabel,
          'U+0043': /* c */ commands.editContent,
          'Enter':          commands.editContent,
          'U+004F': /* o */ commands.insertCodeBlock,
          'U+0049': /* i */ commands.insertTextBlock
        },

        'editContent': {
          'U+001B': /*ESC*/ function() { // ESC
            var block = attachedBlock(selectedElement);

            var type = blockTypes[block.kind];
            type.setContent(block, selectedElement.innerText);
            var newContent = type.getContentElement(block);

            selectBlock(block);
            replaceBlockContent(block);

            mode = modes['select'];
          },
        },

        'editLabel': {
          'U+001B': function() { // ESC
            var label = selectedElement.innerText.trim();
            selectedElement.innerText = label;

            var block = attachedBlock(selectedElement);
            block.label = label;
            selectBlock(block);

            mode = modes['select'];
          },
          'Enter': 'U+001B'
        }
      }

      var mode = modes['select'];

      document.body.onkeyup = function editorKeyUp(evt) {
        evt = evt || window.event;
        kid = evt.key || evt.keyIdentifier;
        handler = mode[kid];
        if (handler) {
          while (typeof(handler) === 'string') {
            handler = mode[handler];
          }
          handler(evt);
        } else {
          console.log(kid);
        }
      };

      renderNotebook(notebook);
    </script>
  </body>
</html>
